"""Unified LLaMA Factory information extraction script - get all information at once and store to file"""
import json
import sys
import subprocess
from dataclasses import fields, MISSING
from pathlib import Path
from typing import get_origin, get_args

# Import LLaMA Factory components
sys.path.insert(0, '/workspace/LLaMA-Factory/src')

from llamafactory.hparams.data_args import DataArguments
from llamafactory.hparams.model_args import ModelArguments  
from llamafactory.hparams.finetuning_args import FinetuningArguments
from llamafactory.extras.constants import METHODS, TRAINING_STAGES, SUPPORTED_MODELS, PEFT_METHODS
from transformers import TrainingArguments

def make_json_serializable(obj):
    """Convert object to JSON serializable format"""
    if isinstance(obj, dict):
        return {k: make_json_serializable(v) for k, v in obj.items()}
    elif isinstance(obj, (list, tuple)):
        return [make_json_serializable(item) for item in obj]
    elif isinstance(obj, (str, int, float, bool, type(None))):
        return obj
    else:
        try:
            return list(obj)
        except (TypeError, ValueError):
            return str(obj)

def extract_field_info(field):
    """Extract complete field information"""
    info = {
        "name": field.name,
        "type": str(field.type),
        "optional": False,
        "default": None,
        "has_default": False,
        "help": "",
        "simple_format": ""  # Add simplified format field
    }
    
    # Check if optional (Union with None)
    origin = get_origin(field.type)
    if origin is not None:
        args = get_args(field.type)
        if len(args) == 2 and type(None) in args:
            info["optional"] = True
            actual_type = args[0] if args[1] is type(None) else args[1]
            info["type"] = str(actual_type)
    
    # Clean type string
    type_str = info["type"].replace("<class '", "").replace("'>", "").replace("typing.", "")
    info["type"] = type_str
    
    # Extract default value
    if field.default is not MISSING:
        info["has_default"] = True
        info["default"] = make_json_serializable(field.default)
    elif field.default_factory is not MISSING:
        info["has_default"] = True
        try:
            default_value = field.default_factory()
            info["default"] = make_json_serializable(default_value)
        except:
            info["default"] = "<factory>"
    
    # Extract help text
    if hasattr(field, "metadata"):
        info["help"] = field.metadata.get("help", "")
    
    # Generate simplified format: "name"(type)[Optional]: help(default=value)
    simple_format = f'"{field.name}"({type_str})'
    if info["optional"]:
        simple_format += "[Optional]"
    if info["help"]:
        simple_format += f": {info['help']}"
    if info["has_default"]:
        simple_format += f"(default={info['default']})"
    info["simple_format"] = simple_format
    
    return info

def extract_class_params(cls):
    """Extract all parameters of a class"""
    params = {}
    for field in fields(cls):
        params[field.name] = extract_field_info(field)
    return params

def get_llama_factory_commit_sha():
    """Get LLaMA Factory git commit SHA"""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', 'HEAD'],
            cwd='/workspace/LLaMA-Factory',
            capture_output=True,
            text=True,
            timeout=10
        )
        return result.stdout.strip() if result.returncode == 0 else None
    except Exception:
        return None

def get_supported_models():
    """Get supported model information"""
    if SUPPORTED_MODELS:
        return make_json_serializable(dict(SUPPORTED_MODELS))
    else:
        # Fallback solution
        return {
            "Qwen/Qwen2.5-1.5B-Instruct": {"hf": "Qwen/Qwen2.5-1.5B-Instruct"},
            "Qwen/Qwen2.5-7B-Instruct": {"hf": "Qwen/Qwen2.5-7B-Instruct"},
            "meta-llama/Llama-3.2-1B-Instruct": {"hf": "meta-llama/Llama-3.2-1B-Instruct"},
            "meta-llama/Llama-3.2-3B-Instruct": {"hf": "meta-llama/Llama-3.2-3B-Instruct"}
        }

def extract_all_info():
    """Extract all LLaMA Factory information"""
    commit_sha = get_llama_factory_commit_sha()
    return {
        "timestamp": "",  # Will be set in Python
        "version": "1.0",
        "commit_sha": commit_sha,
        "methods": list(METHODS),
        "peft_methods": list(PEFT_METHODS), 
        "training_stages": make_json_serializable(dict(TRAINING_STAGES)),
        "supported_models": get_supported_models(),
        "parameters": {
            "data": extract_class_params(DataArguments),
            "model": extract_class_params(ModelArguments),
            "training": extract_class_params(TrainingArguments),
            "finetuning": extract_class_params(FinetuningArguments)
        }
    }

# Save information to structured directory
def save_structured_info(result, base_dir="/workspace/.llama_factory_info"):
    """Save information to structured directory"""
    from pathlib import Path
    import os
    
    base_path = Path(base_dir)
    base_path.mkdir(parents=True, exist_ok=True)
    
    # Create subdirectories
    basic_dir = base_path / "basic"
    params_dir = base_path / "parameters"
    basic_dir.mkdir(exist_ok=True)
    params_dir.mkdir(exist_ok=True)
    
    # Save basic information
    basic_info = {
        "methods": result.get("methods", []),
        "models": result.get("supported_models", {}),
        "peft_methods": result.get("peft_methods", []),
        "training_stages": result.get("training_stages", {})
    }
    
    # Save basic information files separately
    with open(basic_dir / "methods.json", 'w', encoding='utf-8') as f:
        json.dump(basic_info["methods"], f, indent=2, ensure_ascii=False)
    
    with open(basic_dir / "models.json", 'w', encoding='utf-8') as f:
        json.dump(basic_info["models"], f, indent=2, ensure_ascii=False)
    
    with open(basic_dir / "peft_methods.json", 'w', encoding='utf-8') as f:
        json.dump(basic_info["peft_methods"], f, indent=2, ensure_ascii=False)
    
    with open(basic_dir / "training_stages.json", 'w', encoding='utf-8') as f:
        json.dump(basic_info["training_stages"], f, indent=2, ensure_ascii=False)
    
    # Save parameter information
    parameters = result.get("parameters", {})
    for param_type in ["data", "model", "training", "finetuning"]:
        if param_type in parameters:
            with open(params_dir / f"{param_type}.json", 'w', encoding='utf-8') as f:
                json.dump(parameters[param_type], f, indent=2, ensure_ascii=False)
    
    # Save metadata
    metadata = {
        "timestamp": result.get("timestamp", int(time.time())),
        "version": result.get("version", "1.0"),
        "commit_sha": result.get("commit_sha"),
        "last_updated": time.strftime("%Y-%m-%d %H:%M:%S")
    }
    
    with open(base_path / "metadata.json", 'w', encoding='utf-8') as f:
        json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    return str(base_path)

# Extract all information and save to structured directory
if __name__ == "__main__":
    import time
    
    try:
        result = extract_all_info()
        result["timestamp"] = int(time.time())
        result = make_json_serializable(result)
        
        # Save to structured directory
        saved_path = save_structured_info(result)
        
        # Simple success message (no verbose output)
        print("SUCCESS")
        
    except Exception as e:
        print(f"ERROR: {e}")
        import sys
        sys.exit(1)
